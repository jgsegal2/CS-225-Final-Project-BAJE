-Output and correctness of each algorithm: <i>  You should summarize, visualize, or highlight some part of the full-scale run of each algorithm. Additionally, the report should briefly describe what tests you performed to confirm that each algorithm was working as intended.</i>

There are two readinfile() functions, one that takes in no parameters and does the data parsing of the airports and routes for the data from OpenFlights automatically. The second readinfile() takes in two file names, the first for the airports file name and the second for the route file name and can be used to input custom airports and routes. Both functions have no output but do create the graph or airports and routes used in subsequent algorithms. Tests for the data parsing test the number of verticies in the graph, the kind of verticies in the graph, and the proper edges exist.

We decided to use Floyd Warshall to search for the ten closest routes to a passed in distance in kilometers and starting from an origin vertex. Specifically, half of the routes will be the five closest, but greater than the required distance, and the other half will be the five closest, but less than the required distance. For our implementation, since our graph is expressed as an adjacency list, we first had to convert it to a 2D vector to store the vertices and weights. The heart of the Floyd Warshall algorithm was then run on this matrix to get the adjusted shortest paths between all vertex pairs. Because we want only the paths from a specified origin, we filter out these routes and store them in a std::pair so that we can keep track of the ID of the route as we index through. And to get the closest ten routes, we run two loops that each count five corresponding routes to push the three letter ID codes of the destination airports to a final string vector that is returned. Before writing this, we didnâ€™t take into consideration the O(v3) runtime of the algorithm. And with approximately 1500 vertices, the execution on our graph built on just US airports would be too inefficient. Therefore, to at least verify the implementation is functional, we built a smaller graph with six vertices instead to search for only the two closest destinations. 

-Answer to your leading question: <i> You should direct address your proposed leading question. How did you answer this question? What did you discover? If your project was ultimately unsuccessful, give a brief reflection about what worked and what you would do differently as a team. </i>

Our leading question being to find the shortest path in terms of distance between two airports US along with finding airports at a similar distance to offer the user comparative options to go to.
